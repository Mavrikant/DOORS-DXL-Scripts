#include <utils/doctools/itfutil.inc>
pragma runLim,0 // disable timeout limit
//pragma stack, 1500000 // set memory limit

const string exportSources[] = {LS_("String_Current",NLSTEMP_("Current")), LS_("String_All_Linked",NLSTEMP_("All Linked"))}
const string htmlProgressTitle = LS_("String_HTML_Exporter_Progress",NLSTEMP_("HTML Exporter Progress"))

int uniqueOleNumber             = 0

Regexp reRTFUpperASCII = regexp (NLS_("\'[0-9a-fA-F][0-9a-fA-F]")) //'xy, where x and y are hex numbers
const string htmlSep = (NLS_("")) charOf(1) (NLS_(""))

Module expMod             = current
bool   usePictures        = false
bool useChangeMeter = false
bool includeEmptyAttributes = false
Skip   nameList           = null
Skip   skpOpenMods        = create
string extension,exportDir
Stream expFP
IPC    expIPC
string QT                 = (NLS_("\""))
int    soAbsoluteNumber   = 0
Module thisModule
string thisModName
bool   isFormal           = false
bool   showLinks          = true

string webDocumentPrefix
Module webModule

string topModuleName      = NLS_("")
string topModuleFileName  = NLS_("")

bool   socketGenerateFile   = false
Object lastCellTable        = null

bool reported               = false
bool overwriteAll           = false   
bool reportedColumnError    = false

bool quitAfterMemoryWarning = false

Skip skpLinkFiles           = create
Skip skpLinkInfo            = create

/************************************************************************/

const string pcExt              = NLS_(".htm")
const string unixExt            = NLS_(".html")
if (platform == (NLS_("WIN32")) ) {
    extension = pcExt
} else {
    extension = unixExt
}

const string docTreesName       = NLS_("doctrees.gif")
const string bookName           = NLS_("book.gif")
const string docName            = NLS_("doc.gif")
const string worldName          = NLS_("world.gif")
const string doorsicoName       = NLS_("doors8ico.gif")
const string URLouticoName      = NLS_("extlinkout.gif")
const string URLinicoName       = NLS_("extlinkin.gif")

string CdocTrees        
string Cbook            
string Cdoc             
string Cworld           
string Cdoorsico        
string CoutURLico        
string CinURLico        


const string ellipsis           = NLS_("...")
// get source directory
string imageLocation = fileGoodPath_(getenv((NLS_("DOORSHOME"))),(NLS_("lib\\html\\")),(NLS_("lib/html/")))

void initPictureNames() {
        CdocTrees               = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) docTreesName (NLS_("")) QT (NLS_(""))
        Cbook                   = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) bookName (NLS_("")) QT (NLS_(""))
        Cdoc                    = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) docName (NLS_("")) QT (NLS_(""))
        Cworld                  = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) worldName (NLS_("")) QT (NLS_(""))
        Cdoorsico               = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) doorsicoName (NLS_("")) QT (NLS_(""))
        CoutURLico              = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) URLouticoName (NLS_("")) QT (NLS_(""))
        CinURLico               = (NLS_("")) QT (NLS_("")) webDocumentPrefix (NLS_("")) URLinicoName (NLS_("")) QT (NLS_(""))
}


string preURL() {
    if (usePictures) return (NLS_("<img src=")) Cworld (NLS_(" hspace=20 border=0>"))
    return (NLS_(""))
}

    
/************************************************************************/

const string chDateClass        = NLS_("chDate")
const string chDateFileDestName = NLS_("chDate.class")
const string chDateFileSrcName  = NLS_("chDate.cla")
const int    chDateW            = 200
const int    chDateH            = 20
const string paramModCreDate    = NLS_("modCreDate")
const string paramObjCreDate    = NLS_("objCreDate")
const string paramObjModDate    = NLS_("objModDate")
const string paramNoChanges     = NLS_("noChanges")
const string dateAppend         = NLS_(" 00:00:00 GMT")
const string noBreakSpace       = NLS_("&nbsp")



/************************************************************************/

Buffer rtb = create
Buffer htmlBuf = create
Buffer ob = create // outBuffer
Buffer tb = create // tempBuffer
Buffer tb2 = create
Buffer tb3 = create

// Temp buffers used in addLinkToSkip
Buffer link1Buffer = create
Buffer link2Buffer = create

// Temp buffers used in htmlExportLinkInfo
Buffer searchBuffer = create


void truncateBuffer(Buffer& b, int& len, int max) {
    int maxAllowed

    if (null len || null max)
        return

    maxAllowed = max - len

    len += length b
    if (len <= max)
        return

    if (maxAllowed <= 0)
        setempty b
    else
        length(b, maxAllowed)

}

/*****************************************************************************/
int hexToDecimal(char digit)
// DESCRIPTION : Returns decimal interger equivalent of passed hexadecimal
//   digit character.
// RETURNS : decimal integer equivalent or -1 if digit is outside the hex
//   range '0' to 'f' or 'F'.
{
    if ('0' == digit)
    {
        return 0
    }
    if ('1' == digit)
    {
        return 1
    }
    if ('2' == digit)
    {
        return 2
    }
    if ('3' == digit)
    {
        return 3
    }
    if ('4' == digit)
    {
        return 4
    }
    if ('5' == digit)
    {
        return 5
    }
    if ('6' == digit)
    {
        return 6
    }
    if ('7' == digit)
    {
        return 7
    }
    if ('8' == digit)
    {
        return 8
    }
    if ('9' == digit)
    {
        return 9
    }
    if ('a' == digit || 'A' == digit)
    {
        return 10
    }
    if ('b' == digit || 'B' == digit)
    {
        return 11
    }
    if ('c' == digit || 'C' == digit)
    {
        return 12
    }
    if ('d' == digit || 'D' == digit)
    {
        return 13
    }
    if ('e' == digit || 'E' == digit)
    {
        return 14
    }
    if ('f' == digit || 'F' == digit)
    {
        return 15
    }
    return -1
}

/*****************************************************************************/
Buffer upperASCIIToWideChar(Buffer upperASCII, int max)
// DESCRIPTION : Converts any upper ASCII characters in the passed plain text to
//   the corresponding upper ASCII character.  Upper ASCII chars
//   (ASCII code > 127 and < 256) are represented in RTF in the form (NLS_("\'xy"))
//   (excluding the double quotes) where xy is the ASCII code in hexadecimal.
//   This function replaces the RTF representation with the corresponding
//   upper ASCII char.
//   For e.g., upper ASCII character (NLS_("'c4")) is replaced by (NLS_("¢)).
//   NOTE: The function uses the 'max' parameter passed to restrict converting
//   any upper ASCII characters beyond max length; it does not truncate the
//   passed string.
// RETURNS : converted text
{
    Buffer wideChar = create
    int from = 0, to = 0, upperASCIIMSN = 0, upperASCIILSN = 0, upperASCIICode = 0
    char digit = null, wide = null
    while (search(reRTFUpperASCII, upperASCII, from))
    {
        digit = upperASCII[from + start 0 + 1] //MSN (Most Significant Nibble) hex number
        upperASCIIMSN = hexToDecimal(digit)
        if (-1 != upperASCIIMSN)
        {
            digit = upperASCII[from + start 0 + 2] //LSN (Least Significant Nibble) hex number
            upperASCIILSN = hexToDecimal(digit)
            if (-1 != upperASCIILSN)
            {
                upperASCIICode = (upperASCIIMSN * 16) + upperASCIILSN //upperASCIICode = (x * 16) + y
                wide = charOf(upperASCIICode)
                //Append the string between the previous and current
                // matches to the wide char string.
                if (start 0 > 1)
                {
                    wideChar += upperASCII[from : from + start 0 - 2]
                }
                wideChar += wide
                if (length wideChar >= max)
                {
                    break
                }
            }
        }
        from += end 0 + 1
    }
    //Append any string after the last match
    if (0 == from)
    {
        //No upper ASCII characters found.
        delete wideChar
        wideChar = null
    }
    else if ((from < length(upperASCII)) && (length wideChar < max))
    {
        //Append the string following the last match
        wideChar += upperASCII[from :]
    }
    return wideChar
}

void convertRichText(Buffer& b, string s, int& len, int max)
// DESCRIPTION : Converts passed rich text in NLS_("s") to HTML.  Restricts the
//   HTML string length to 'max' or less.
//   Any upper ASCII characters in the RTF string are converted to the
//   corresponding wide characters.
// RETURNS : nothing
{
    
    RichText rt
    bool     limitText

    if (!null len && !null max)
        limitText = true
    else
        limitText = false

    if (limitText && len >= max)
        return

    setempty b

    for rt in s do {
        if (limitText && len >= max)
            break
        setempty tb2
        tb2 += rt.text
        Buffer wideChar = upperASCIIToWideChar(tb2, max)
        if (!null wideChar)
        {
            tb2 = stringOf wideChar
            delete wideChar
        }
        if (limitText)
        {
            truncateBuffer(tb2, len, max)
        }
        safeHTMLBuffer(tb2, true, true)
        if (rt.bold)
            b += (NLS_("<b>"))
        if (rt.underline)
            b += (NLS_("<u>"))
        if (rt.italic)
            b += (NLS_("<i>"))
        if (rt.strikethru)
            b += (NLS_("<s>"))
        if (rt.superscript)
            b += (NLS_("<sup>"))
        if (rt.subscript)
            b += (NLS_("<sub>"))
        if (rt.charset == charsetSymbol)
            b += (NLS_("<font face=\"Symbol\">"))
        b += tb2
        if (rt.charset == charsetSymbol)
            b += (NLS_("</font>"))
        if (rt.subscript)
            b += (NLS_("</sub>"))
        if (rt.superscript)
            b += (NLS_("</sup>"))
        if (rt.strikethru)
            b += (NLS_("</s>"))
        if (rt.italic)
            b += (NLS_("</i>"))
        if (rt.underline)
            b += (NLS_("</u>"))
        if (rt.bold)
            b += (NLS_("</b>"))
        if (rt.newline)
            b += (NLS_("<br>"))
    }
}

Buffer richTextProbeAttr(Object o, string attrName, int& len, int max) {
    string s

    setempty rtb

    if (null o)
        return rtb

    if (attrName == (NLS_("Object Identifier")))
        rtb += (identifier o (NLS_("")))
    else if (attrName == (NLS_("Object Number")))
        rtb += (number o (NLS_("")))
    else if (attrName == (NLS_("Object Level")))
        rtb += (level o (NLS_("")))

    if (length(rtb) > 0) {
        truncateBuffer(rtb, len, max)

        return rtb
    }

    Module oldc = current
    current = (module o)
    if (!exists attribute attrName || !canRead o.attrName) {
        if (! null oldc) current = oldc
        return rtb
    }

    if (! null oldc) current = oldc

    s = richTextWithOle o.attrName
    convertRichText(rtb, s, len, max) 

    return rtb
}


Object cellTable(Object o) {

    Object o2 = parent o
    if (! null o2) 
        return (parent o2)
    else
        return null
}

void writeHTMLtoFile() {

    expFP << ob
    setempty ob
    ob = (NLS_(""))
}

string guessExportName(string dirName, modName, ext) {
    if (modName == topModuleName)
        return topModuleFileName
    else
        return dirName goodFileName(modName) extension
}

void addHTMLHeader(string modName)  
{
    ob += (NLS_("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"))
    ((((ob += (NLS_("<html>\n<head>\n<META HTTP-EQUIV="))) += QT) += (NLS_("Content-Type"))) += QT)
    (((((ob += (NLS_(" CONTENT=")))+= QT) += (NLS_("text/html; charset=UTF-8"))) += QT) += (NLS_(">\n")))
    ((ob += (NLS_("<title>"))) += modName) += (NLS_("</title>\n"))
    ob += (NLS_("<style>\n    * { box-sizing: border-box; }\n    a:link { text-decoration: none; }\n    a:visited { text-decoration: none; }\n    a:hover { text-decoration: none; }\n    a:active { text-decoration: none; }\n\n    #searchBar {\n        background-image: url(\'https://upload.wikimedia.org/wikipedia/commons/a/a5/Antu_gnome-search-tool.svg\');\n        background-size: 30px 30px;\n        background-position: 5px 5px;\n        background-repeat: no-repeat;\n        width: 100%;\n        font-size: 16px;\n        padding: 10px 20px 10px 40px;\n        border: 1px solid #ddd;\n        margin-bottom: 12px;\n    }\n\n    #DoorsTable {\n        border-collapse: collapse;\n        width: 100%;\n        border: 1px solid #ddd;\n        font-size: 12px;\n        font-family: Verdana, Geneva, sans-serif; \n    }\n\n    #DoorsTable th,\n    #DoorsTable td {\n        text-align: left;\n    }\n\n    #DoorsTable tr:hover {\n        background-color: rgb(235, 243, 242);\n    }\n\n    #DoorsTable th.header {\n        cursor: pointer;\n        background: rgb(0, 212, 160);\n    }\n\n    #DoorsTable thead tr th {\n        font-weight: bold;\n    }\n\n    #DoorsTable thead tr th span {\n        padding-right: 20px;\n        background-repeat: no-repeat;\n        background-position: 100% 100%;\n    }\n</style>\n"))
    ob += (NLS_("<script type=\"text/javascript\" src=\"./js/jquery-latest.js\"></script>\n"))
    ob += (NLS_("<script type=\"text/javascript\" src=\"./js/jquery.tablesorter.min.js\"></script>\n"))
    ob += (NLS_("<script type=\"text/javascript\" src=\"./js/colResizable-1.5.min.js\"></script>\n"))
    ob += (NLS_("</head>\n"))
    ob += (NLS_("<BODY>\n"))
    ob += (NLS_("<input type=\"text\" id=\"searchBar\" onkeyup=\"searchBarFunction()\" placeholder=\"Search for names..\" title=\"Type in a name\">\n"))
    writeHTMLtoFile()
} 

/************************************************************************/

void addHTMLFooter() {
    ob += (NLS_("<p><DIV align=\"center\">"))
    ob += "Export time: " dateOf(intOf(today())) "\n</br>"
    ob += (NLS_("Produced with <a href = \"https://github.com/Mavrikant/DOORS-DXL-Scripts\">Mavrikant/DOORS-DXL-Scripts</a>"))
    ob += (NLS_("</DIV></p>"))
    writeHTMLtoFile()
}

/************************************************************************/
void dumpApplet(string appName, int w,h) {
    //STRING
    (((((((ob += (NLS_("\n\t<applet code="))) += appName) += (NLS_(" width = "))) += (w (NLS_("")))) += (NLS_(" height = "))) += (h (NLS_("")))) += (NLS_(">\n")))
    writeHTMLtoFile()
}

void dumpParam(string paramName, string val) {
    (((((((ob += (NLS_("\t<param name="))) += paramName) += (NLS_(" value = "))) += QT) += val) += QT) += (NLS_(">\n")))
    writeHTMLtoFile()
}

void closeApplet() {
    ob += (NLS_("\t</applet>\n"))
    writeHTMLtoFile()
}

/************************************************************************/
void dumpCloser() {
    ob += (NLS_("\n<script>\n    function searchBarFunction() {\n        var input, filter, table, tr, td, i, txtValue;\n        input = document.getElementById(\"searchBar\");\n        filter = input.value.toUpperCase();\n        table = document.getElementById(\"DoorsTable\");\n        tr = table.getElementsByTagName(\"tr\");\n        for (i = 1; i < tr.length; i++) {\n            td = tr[i].getElementsByTagName(\"td\");\n            tr[i].style.display = \"none\";\n            td = tr[i].getElementsByTagName(\"td\")[2];\n            if (td) {\n                txtValue = td.textContent || td.innerText;\n                if (txtValue.toUpperCase().indexOf(filter) > -1) {\n                    tr[i].style.display = \"\";\n                }\n            }\n        }\n    }\n    $(function() {\n        $(\"#DoorsTable\").tablesorter();\n    });\n    $(function() {\n        $(\"#DoorsTable\").colResizable({\n            liveDrag:true,\n            gripInnerHtml:\"<div class=\'grip\'></div>\", \n            draggingClass:\"dragging\"\n        });\n    });\n</script>\n"))
    ob += (NLS_("\n</body>\n</html>"))
    writeHTMLtoFile()
}

Buffer linkIdent(Object o) {
    int len = 0

    setempty tb
    current = module o

    if (exists attribute AHeading)
    {
        tb += richTextProbeAttr(o, AHeading, len, 40)
    }

    if ((length(tb) == 0) && (exists attribute AShortText))
    {
        tb += richTextProbeAttr(o, AShortText, len, 40)
    }

    if ((length(tb) == 0) && (exists attribute ALongText))
    {
        tb += richTextProbeAttr(o, ALongText, len, 40)
    }

    (((tb += (NLS_(" ("))) += (identifier o)) +=  (NLS_(")")))

    return tb
}



bool dumpHeading(Object obj, bool addNumber) {
    setempty tb
    current = module obj
    if (exists attribute AHeading)
        htmlText(tb, obj.AHeading, true, false, preURL (NLS_("")), (NLS_("")))
    if  (length(tb) > 0) {
            (((ob += (NLS_("<H"))) += ((level obj) (NLS_("")))) += (NLS_("> ")))
        if (addNumber)
            (ob += (number obj)) += (NLS_("  "))
        writeHTMLtoFile()
        ob += tb
        (((ob +=(NLS_("</H"))) += ((level obj) (NLS_("")))) += (NLS_(">\n")))
        writeHTMLtoFile()
        return true
    }
    return false
}  


string getBaseFilename(Object obj, string pictureType, string from, string ident)
{
    //Replaced the obj.(NLS_("Absolute Number")) with a global integer uniqueOleNumber which is 
    //incremented everytime the function is called. It extracts the unique filename for the
    //OLE object to be exported. It is a better option rather than using the Absolute number 
    //since the user may not have access rights either on the object or on the attribute value
    //In such a case, the Absolute number poses a lot of problems.
    
    return goodFileName(pictureType (uniqueID module fullName(module obj)) (uniqueOleNumber++) from (NLS_("-")) ident  (NLS_("-"))  )
}     


//****************************************************************************
bool dumpBody(Object obj) {
    setempty tb
    current = module obj
    bool isOutput = false     
    
    if (exists attribute ALongText)
    {
        string oleBaseFileName  = getBaseFilename(obj, (NLS_("OLE")), (NLS_("Attribute")), ALongText)
        htmlText(tb, obj.ALongText, true, false, preURL (NLS_("")), (NLS_("")),exportDir, oleBaseFileName)  
    }
    if (!outlining module obj && (length(tb) >0)) {
        isOutput = true
        ob += tb
        writeHTMLtoFile()
    }
    if (!outlining module obj){
       
        bool isPicture = (probeAttr_(obj, (NLS_("Picture"))) == (NLS_("True")))
        
        if (isPicture && showPictures(current) ){
            bool doPicture = true

            // add entire path of the module with the picturename in the picture file name
            string pathName = fullName (current Module)
            string pictName = pathName (NLS_("_")) probeAttr_(obj,(NLS_("PictureName")))
            string longPictName
           
            pictName = goodFileName (pictName (NLS_(".png")))
            longPictName = exportDir pictName
            if (fileExists_ longPictName){
                doPicture = fileOverwriteOK_(longPictName, overwriteAll) 
            }// if fileExists_
            if (doPicture){
                 string s = exportPicture(obj, longPictName , formatPNG_)
                 if (!null s and !reported) {
                     reported = true
                     errorBox dxlStrformat(getExtMsg("String_Error_exporting_picture_s",NLSTEMP_("Error exporting picture: %s")), s )
                 }
                 else{
                     (((ob += (NLS_("<br><img src="))) += pictName) += (NLS_("> ")))
                     writeHTMLtoFile()
                     isOutput = true
                 }
            }//doPicture
        }// isPicture ...
    
     }  // !outlining    
     if (isOutput){
         ob += (NLS_("<br>\n"))
         writeHTMLtoFile()
         return true
     }// isOutput

    
    return false
}

//Function to dump the table attribute values (Main column attributes)
bool dumpTableAttributes (Object obj)
{
    setempty tb
    if(!canRead obj)
    {
        return false
    }    
    string attributeName = getDisplayedAttributeName(obj)
    if(exists attribute attributeName)
    {
        if(!canRead(obj.attributeName) || null obj.attributeName)
        {
            return false
        }
        string oleBaseFileName  = getBaseFilename(obj, (NLS_("OLE")), (NLS_("Attribute")), attributeName)
        htmlText(tb, obj.attributeName, true, false, preURL (NLS_("")), (NLS_("")),exportDir, oleBaseFileName)  
    }

    if ((length(tb) >0)) 
    {
        ob += tb
        writeHTMLtoFile()

        ob += (NLS_("<br>\n"))
        writeHTMLtoFile()
        return true
    }
    return false    
}//DumpTableAttributes

bool htmlExportLinkInfo(string l1, string l2, string modName, bool inTable, bool showPictures) {

    bool   outlink
    string target_mod, absNo, ident
    string picName, altText
    
    outlink = true
    if (l1[0] == 'I') outlink = false
    target_mod = l1[1:]
    
    searchBuffer = target_mod
    string target_mod_str = target_mod
    int index = contains(searchBuffer, '[')
    if (index != -1)
    {
        target_mod_str = searchBuffer[0:index-1]
    }

    searchBuffer = l2
    index = contains(searchBuffer, ':', 1)
    if (index == -1)
    {
        return false;
    }
    absNo = searchBuffer[0:index-1]
    ident = searchBuffer[index+1:]


    if (outlink)
        ob+= (NLS_("⮞"))
    else
        ob += (NLS_("⮜"))
    ((ob += (NLS_("<a href = "))) += QT)
        if (target_mod != modName ) 
            ob += getFileOf(guessExportName((NLS_("")), target_mod, extension))
        if ( target_mod != modName ) {
            if (type module target_mod_str == (NLS_("Formal")) ){
                picName = CdocTrees
                altText = dxlStrformat(LS_("String_Link_to_formal_module_s",NLSTEMP_("Link to formal module %s")), target_mod_str)
            }
            else 
            {
                picName = Cbook
                altText = dxlStrformat(LS_("String_Link_to_module_s",NLSTEMP_("Link to module %s")), target_mod_str)
            }
        } else {
            picName = Cdoc
            altText = LS_("String_Internal_link",NLSTEMP_("Internal link"))
        }
        ((((ob += (NLS_("#X"))) += absNo) += QT) += (NLS_("> ")))

        if (showPictures && (!inTable))
            (((((ob += (NLS_("<img src="))) += picName) += (NLS_(" alt=\""))) += altText) += (NLS_("\" hspace=20 border=0>")))
        ob += ident
        ob += (NLS_("</a>"))

        ob += (NLS_("<br>\n"))
        writeHTMLtoFile()

    return true
    
}

void htmlExportExternalLinkInfo(ExternalLink l, bool inTable, bool showPictures, string absNo) {
    bool outlink
    bool isURL
    string picName
    string altText
     
    string linkName = name(l)
    string linkDescription =  description(l)
    htmlBuf =  body(l)

    outlink = outward == direction(l) ? true : false 
    isURL = openAsURL == behaviour(l) ? true : false 

    ((ob += (NLS_("<a href = "))) += QT)
    if (outlink) {
        picName = CoutURLico
        altText = dxlStrformat(LS_("String_Outgoing_external_link_s",NLSTEMP_("Outgoing external link: %s")), linkDescription)
    } else {
        picName = CinURLico
        altText = dxlStrformat(LS_("String_Incoming_external_link_s",NLSTEMP_("Incoming external link: %s")), linkDescription)
    }

    safeHTMLBuffer(htmlBuf, true, false)
    if (isDefaultURL(stringOf(htmlBuf)))
    {
        ob += (NLS_("http://"))
    }
    ((ob += htmlBuf (NLS_("")) ) += QT) 

    ob += (NLS_(" title = "))  
    ob += QT   
    ob += linkName   
    ob += QT   
    ob += (NLS_("> "))

    if (showPictures && (!inTable)){
        ob += (NLS_("<img src="))
        ob += picName
        ob += (NLS_(" alt=\""))
        ob += altText
        ob += (NLS_("\" hspace=20 border=0>"))
    }
    ob += linkDescription
    ob += (NLS_("</a>"))   
    
    if (outlink){
        ob += (NLS_("(EXT OUT"))
    } else {
        ob += (NLS_("(EXT IN"))
    }

    if (!isURL){
        ob += (NLS_(", No URL"))
    }
    ob += (NLS_(")"))
    ob += (NLS_("<br>\n"))
    writeHTMLtoFile()
}

bool htmlExportExternalLinksInfo(Object o, bool inTable, bool showPictures) {
    ExternalLink l;
    bool writtenHeader = false; 
    bool generatedLinks = false; 
    
    string absNo = (probeAttr_(o, (NLS_("Absolute Number"))))
    if (null absNo) 
    {   
        return false;
    }

    for l in all (o<-(NLS_("*"))) do {
        if (!writtenHeader && !inTable && !cell(o)){
            // If we are in book view, not in a table and this is the first external link then
            // output thes (NLS_("header")) 
            ob += (NLS_("\n<p><b>")) LS_("String_This_object_has_external_links_to",NLSTEMP_("This object has external links to:")) (NLS_("</b><br>"))
            writtenHeader = true
        }
        // Add Link Info to the skip list
        htmlExportExternalLinkInfo(l, inTable, showPictures, absNo)
        generatedLinks = true;
    }
    for l in all (o->(NLS_("*"))) do {
        if (!writtenHeader && !inTable && !cell(o)){
            // If we are in book view, not in a table and this is the first external link then
            // output thes (NLS_("header"))
            ob += (NLS_("\n<p><b>")) LS_("String_This_object_has_external_links_to",NLSTEMP_("This object has external links to:")) (NLS_("</b><br>"))
            writtenHeader = true
        }
        // Add Link Info to the skip list
        htmlExportExternalLinkInfo(l, inTable, showPictures, absNo)
        generatedLinks = true;
    }

    return generatedLinks
}


//****************************************************************************
void htmlInlineTable(Object t) 
// DESCRIPTION : traverses a table and generates html code for the table
// RETURNS : void
{
    Object r,c
    bool useWidth, textDone
    string modName 
    int nrows = 0
    int ncells = 0
    int prev_rowwidth = 0       //stores the width of the previous row
    int current_rowwidth =0     //stores the width of the current row
    //Set the default width to 150 incase the user does not have read acess on the 
    //table cell and on the TableCellWidth attribute.
    const int defaultCellWidth = 150
    
    if (null t) {
        return
    }
    current = module t
    modName = fullName (current Module)
    useWidth = exists attribute ACellWidth
    ((((((ob += (NLS_("<a name="))) += QT) += (NLS_("X"))) += (probeAttrBuff_(t, (NLS_("Absolute Number"))))) += QT) += (NLS_("> \n")))
    ob += (NLS_("</a>"))
    if (! tableContents(current Module)) {
        ob += (NLS_(">> Table"))
        writeHTMLtoFile()
        return
    }

    for r in t do {
        ncells = 0
        for c in r do {
            if (!isVisible c) continue
            ncells++
        }
        if (ncells > 0) nrows++
    }

    if (nrows == 0) return

    // counts the number of rows in a table
    nrows = 0

    for r in t do {
        ncells = 0
        for c in r do {
            if (!isVisible c) continue 
            ncells++
            // get the total width of the row
            //Set the cellwidth to default cellwidth in case the user 
            //does not have read access on the TableCellWidth attrib
            //and on the table cell itself.
            int cellwidth = 0
            if(canRead c && canRead c.ACellWidth)
            {
                cellwidth = c.ACellWidth
            }
            else
            {
                cellwidth = defaultCellWidth
            }
            current_rowwidth = current_rowwidth + cellwidth
        }

        if (ncells == 0) continue
        nrows++
        // if width of the previous row and the current row is not same start a new table
        if (current_rowwidth != prev_rowwidth) {
            // if it is the first row end tag of a table should not be there
            if (nrows > 1) {
                // put end tag of a table
                ob += (NLS_("</table>\n"))
                writeHTMLtoFile()
            }
            // put start tag of a table
            ob += (NLS_("<table border = 1 cellPadding = 0 cellSpacing = 0>\n"))
            writeHTMLtoFile()
        }
        // swap current row width into another variable
        prev_rowwidth = current_rowwidth
        current_rowwidth = 0

        ob += (NLS_("<tr>\n"))
        for c in r do {
            if (!isVisible c) continue
            textDone = false
            if (useWidth) {
                //STRING
                string wd = probeAttr_(c, ACellWidth)
                if (null wd) wd = (NLS_("150"))
                //instead of width use colspan
                (((((((ob += (NLS_("<td colSpan="))) += wd) += (NLS_(" valign="))) += QT) += (NLS_("top"))) += QT) += (NLS_(">")))
            } else {
                (((((ob += (NLS_("<td valign="))) += QT) += (NLS_("top"))) += QT) += (NLS_(">")))
            }
            //STRING
            ((((((ob += (NLS_("<a name="))) += QT) += (NLS_("X"))) += (probeAttrBuff_(c, (NLS_("Absolute Number"))) (NLS_("")))) += QT) += (NLS_("> \n")))
            ob += (NLS_("</a>"))
            writeHTMLtoFile()
            //If the object cannot be read continue
            if(!canRead c)
            {
                continue
            }
            string attributeName = getDisplayedAttributeName(c)
            if(null attributeName)
            {
                textDone = (dumpHeading(c,false)) || textDone
                textDone = (dumpBody c) || textDone
            }
            else
            {
                textDone = (dumpTableAttributes (c))    
            }            
            // Access cached link information
            string absNo = probeAttr_(c, (NLS_("Absolute Number")))
            bool addedLinks = false // Keep track of whether or not we've added links (either normal or external)
            if ((showLinks) && (! null absNo) && (! null skpLinkInfo)) {
                Skip skpLinks
                if (find(skpLinkInfo, absNo (NLS_("")), skpLinks)) {
                    string linkTarget, linkText
                    for linkTarget in skpLinks do {
                    	linkText = (string key skpLinks)
                        linkText = linkText[0:length(linkText)-(length(linkTarget)+1)]
                        addedLinks = htmlExportLinkInfo(linkTarget, linkText, modName, false, false) || addedLinks
                    }
                }
            }

            if (showLinks) {
                addedLinks = htmlExportExternalLinksInfo(c, false, false) || addedLinks                
            }

            // Add a no-break space char in case the cell is empty so
            // that it is displayed in the exported HTML Doc. An empty cell's
            // borders are not displayed so it does not appear in HTML Doc
            // if we let it remain empty. Earlier ellipsis was added. But 
            // this was considered a bug since ellipsis appeared in the empty cell
            // but unlike ellipsis, noBreakSpace won't appear in the exported Doc.
            if(!textDone && (!showLinks || !addedLinks))
            {
                ob += noBreakSpace
            }

            ob += (NLS_("</td>\n"))
            writeHTMLtoFile()

        }
        ob += (NLS_("</tr>\n"))
        writeHTMLtoFile()
    }

    ob += (NLS_("</table>\n"))
    writeHTMLtoFile()

} //htmlInlineTable
       
       
//****************************************************************************
string exportPicture(Column col, Object obj, string basefileName, Buffer &tb)
// DESCRIPTION : adds an html reference to a png of the picture in col for obj
//               exports the picture to exportDir       
//               htmlText must have called in the column.
//               and hasPicture must have returned true.
// RETURNS :     an error message if anything went wrong

{              
    Module m = module obj
    string pictureName =  basefileName (NLS_(".png"))
    
    string error = exportPicture(col, obj, exportDir pictureName, formatPNG_)  
    if (hasPicture(col)) 
    {
        tb += (NLS_("<br><img src="))
        tb += pictureName (NLS_("> "))
    }    
    else
    {
        tb += (NLS_("<br>"))
    }
        
    return error;
    
}//exportPicture



 


/************************************************************************/

void do_htmltable (Module m) {

    Object obj
    Column col
    string j
    int w
    Skip skpLinks
    string modName = fullName m


    thisModName = fullName m
    thisModule = m
    lastCellTable = null
    addHTMLHeader(modName)

    ob += (NLS_("<table id=\"DoorsTable\" class=\"tablesorter\" border>\n<thead>\n<tr>\n"))

    for col in m do {
        string colTitle = title col
        if (colTitle == (NLS_(""))) colTitle = (NLS_("..."))
        w = width col
        j = justify col
        if (j == (NLS_("Left and Right"))) j = (NLS_("Center"))
        //STRING
        (((((((ob += (NLS_("<th width="))) += (w (NLS_("")))) += (NLS_(" align="))) += j ) += (NLS_(">"))) += colTitle) += (NLS_("</th>\n")))
    }
    // now the heading for the links column
    if (showLinks) ob += (NLS_("<th>Links</th>\n"))
   
    ob += (NLS_("</tr>\n</thead>\n"))
    writeHTMLtoFile()

    initNotDisplayedOpenModules() 
    for obj in m do 
    {
        if (isFormal && (cell obj)) {
            Object t = cellTable(obj)
            if (t == lastCellTable) continue
        }

        int absNo 
        if (canRead obj.(NLS_("Absolute Number"))) 
            absNo = obj.(NLS_("Absolute Number"))
        else 
            absNo = -1

        ob += (NLS_("<tr>"))
		
		int columnIndex = 0
        for col in m do {
            (ob += (NLS_("<td>")))
			
			if (main col) {
                if (! canRead obj) {
                    ob += (NLS_("<")) LS_("String_Read_locked_data",NLSTEMP_("Read locked data")) (NLS_(">"))
                    writeHTMLtoFile()
                    continue
                }
                if (isFormal && (table obj)) {
                   htmlInlineTable(obj)
                   lastCellTable = obj
                } else if (isFormal && (cell obj)) {
                    Object t = cellTable(obj)
                    htmlInlineTable(t)
                    lastCellTable = t
                } else {
                    setempty tb
                    htmlText(tb, obj.AHeading, true, false, (NLS_("")), (NLS_("")))
                    bool textDone

                    ((((((ob += (NLS_("<a name="))) += QT) += (NLS_("X"))) += (probeAttrBuff_(obj, (NLS_("Absolute Number"))))) += QT) += (NLS_("> \n")))
                    ob += (NLS_("</a>"))

                    writeHTMLtoFile()

                    if (length(tb) > 0) {
                        ob += (NLS_("<b>"))
                        ob += (number obj)
                        ob += (NLS_("  "))
                        writeHTMLtoFile()
                        ob += tb
                        ob += (NLS_("</b><br>"))
                        writeHTMLtoFile()
                        textDone = true
                    } else
                        textDone = false

                    writeHTMLtoFile()
                    textDone = (dumpBody obj) || textDone
                    if (!textDone)
                        ob += ellipsis
                }
                writeHTMLtoFile()
            }
            else {
                setempty tb  
                
                string oleBaseFilename  = getBaseFilename(obj, (NLS_("OLE")), (NLS_("Column")) ,columnIndex (NLS_("")))
                       
                htmlText(tb, col, obj, true, false, preURL (NLS_("")), (NLS_("")), exportDir, oleBaseFilename) 
                if (hasDXLCanvas(col))
                {    
                    string layoutBaseFilename =  getBaseFilename(obj, (NLS_("Layout")), (NLS_("Column")),columnIndex (NLS_("")))              
                    // some layout DXL has drawn a picture in the column
                    // we want to export it
                    string error = exportPicture(col, obj,  layoutBaseFilename, tb)   
                    if ((!null error) and !reportedColumnError)
                    {
                        errorBox (dxlStrformat(getExtMsg("String_Error_exporting_picture_of_column_s_s",NLSTEMP_("The picture of the %s column was not exported. More information: %s.")), (title col) (NLS_("")), error)) 
                        reportedColumnError = true  
                    } 


                } else 
                {
                    if (length(tb) == 0)
                    {
                        tb += (NLS_("<br>"))
                    }
                }
                
                ob += tb
                writeHTMLtoFile()
            }
            ob += (NLS_("</td>\n"))
            writeHTMLtoFile()   
            columnIndex++
        } //for col in m
        if (showLinks) {
            // now that we have output all the columns, lets try to output a (NLS_("Links")) column
            Link thislink
            bool noLinks = true

            ob += (NLS_("<td NOWRAP>"))
            writeHTMLtoFile()

            if ((absNo != -1) && (! null skpLinkInfo)) {
                if (find(skpLinkInfo, absNo (NLS_("")), skpLinks)) {
                    string linkTarget, linkText
                    for linkTarget in skpLinks do {
                    	linkText = (string key skpLinks)
                        linkText = linkText[0:length(linkText)-(length(linkTarget)+1)]
                        if (htmlExportLinkInfo(linkTarget, linkText, modName, true, usePictures)) noLinks = false
                    }
                }
            }

            if (!null obj && (null (cell obj))) {
                noLinks = !htmlExportExternalLinksInfo(obj, true, usePictures) || noLinks
            }

            if (noLinks) (((ob += (NLS_("<small>"))) += ellipsis) += (NLS_("</small>")))

            ob += (NLS_("</td>\n"))
        }
        ob += (NLS_("</tr>\n"))

        writeHTMLtoFile()
    }
    closeNotDisplayedOpenedModules()

    ob += (NLS_("</table>\n"))
    addHTMLFooter()
    dumpCloser
    writeHTMLtoFile() 
}

int getMods(Object o) {
    History h
    int count = 0
    for h in o do {
        count++
    }
    return count
}



bool htmlExportListObject(Object obj) {

        Column col
        Link thislink

        if (isFormal && (table obj)) {
            htmlInlineTable obj
            lastCellTable = obj
            return true
        }

        if (isFormal && (cell obj)) {
            Object t = cellTable(obj)
            htmlInlineTable t
            lastCellTable = t
            return true
        }

        if (isFormal && (cell obj)) 
        {
            dumpHeading(obj,false)
            dumpBody obj
        } else 
        {  
            int columnIndex = 0
            for col in thisModule do {
                if (main col) {
                    //Display Read Locked in case the user does not have access to 
                    //the object.
                    if (!canRead obj) 
                    {
                        ob += (NLS_("<")) LS_("String_Read_locked_data",NLSTEMP_("Read locked data")) (NLS_(">"))
                        writeHTMLtoFile()
                        continue
                    }
                    bool firstPass = true
                    current = module obj
                    dumpHeading(obj,true)
                    dumpBody obj
                    string absNo = probeAttr_(obj, (NLS_("Absolute Number")))

                    // enumerate any DOORS links
                    if ((showLinks) && (! null absNo) && (! null skpLinkInfo)) {
                       Skip skpLinks
                       if (find(skpLinkInfo, absNo, skpLinks)) {
                           string linkTarget
                           string linkText
                           for linkTarget in skpLinks do {
                               if (firstPass) {
                                   ob += (NLS_("\n<p><b>")) LS_("String_This_object_is_linked_to",NLSTEMP_("This object is linked to:")) (NLS_("</b><br>"))
                                   firstPass = false
                               }
                               linkText = (string key skpLinks)
                               linkText = linkText[0:length(linkText)-(length(linkTarget)+1)]
                               htmlExportLinkInfo(linkTarget, linkText, thisModName, false, usePictures)
                           }
                           ob += (NLS_("\n<p>\n"))
                       }
                    }
                    writeHTMLtoFile()
            
                    if (!null obj && (null (cell obj))) {
                        htmlExportExternalLinksInfo(obj, false, usePictures)
                    }        
                                        
                } // end of main column
                else {
                    // just another column
                    setempty tb      
                   
                    string oleBaseFileName  = getBaseFilename(obj, (NLS_("OLE")), (NLS_("Column")), columnIndex (NLS_("")))
                    htmlText(tb, col, obj, true, false, preURL (NLS_("")), (NLS_("")),exportDir, oleBaseFileName)
                    if (!includeEmptyAttributes && length tb == 0) continue

                    (((ob += (NLS_("\n<i>"))) += (title(col))) += (NLS_(":</i> ")))
                    writeHTMLtoFile()

                    ob += tb
                    ob += (NLS_("\n<p>"))
                    writeHTMLtoFile()
                } // end of not main column    
                columnIndex++
            } // end of for column in module
        }

        writeHTMLtoFile()

        if (useChangeMeter) {
            //Load the change meter applet only if the current user has read access 
            //to the current object and to the Created On and Last Modified on attributes
            if(canRead obj)
            {
                if(canRead(obj.ACreatedOn) && canRead(obj.ALastModifiedOn))
                {
                    dumpApplet(chDateClass, chDateW, chDateH)
                    dumpParam(paramModCreDate, thisModule.ACreatedOn dateAppend)
                    dumpParam(paramObjCreDate, obj.ACreatedOn dateAppend)
                    dumpParam(paramObjModDate, obj.ALastModifiedOn dateAppend)
                    dumpParam(paramNoChanges, (getMods obj) (NLS_("")))
                    closeApplet()
                }
            }
        }

        return true
}

/************************************************************************/

void do_htmllist (Module m) {

    string attr
    Object obj, target_obj
    Column col
    Link thislink
    string target_mod, picName
    int absNo

    thisModName = fullName m
    thisModule = m
    lastCellTable = null

    addHTMLHeader(thisModName)

    initNotDisplayedOpenModules() 
    for obj in m do 
    {
        if (isFormal && (cell obj)) {
            Object t = cellTable(obj)
            if (t == lastCellTable) continue
        }
        ((((((ob += (NLS_("<a name="))) += QT) += (NLS_("X"))) += (probeAttrBuff_(obj,(NLS_("Absolute Number"))))) += QT) += (NLS_("> \n")))
        ob += (NLS_("</a>"))

        writeHTMLtoFile()
        if (htmlExportListObject(obj)) ob += (NLS_("<hr>\n"))
        writeHTMLtoFile()
    } // end of for object in module
    closeNotDisplayedOpenedModules()
    addHTMLFooter()
    dumpCloser 
}


/**********************************************************************
 Functions for caching and reloading link information for the modules
**********************************************************************/


/***********************************************************************
   getLinkFileName
   returns the name of the temporary filename of link information stored 
   for the specified module
*/

string getLinkFileName(string modName) {
    string fName
    if (find(skpLinkFiles, modName, fName)) return fName

    fName = tempFileName
    put(skpLinkFiles, modName, fName)
    return fName

}
//  ****************************************
//  This methods replaces the nonreadable Characters (Decimal code 31 or less or hex 1F and less)
//  with space character. This method is used in Export to HTML action in UI interface.  
//  Without this conversion;the Export html operation will hang DOORS application.
//  ******************************************
string removeNonReadableChars(string s1){

    Buffer b = create
    b = s1
    int i = 0
    while(i < length(b))
    {
        if(b[i] <= ' ')
        {
            set(b,i,' ')
        } 
        i++
    }
    string s = stringOf(b)
    delete b
    return s
}

void writeLinkInfoFile(string mn, Skip& skpInfo) {

    Skip   skpLinks
    string fn = getLinkFileName(mn)
    Stream s = write(fn, CP_UTF8)
    if (null s) return
    for skpLinks in skpInfo do {
       string l1, l2
       string absNo = (string key skpInfo)
       s << absNo (NLS_("\n"))
       for l1 in skpLinks do {
           l2= (string key skpLinks)
           l1= removeNonReadableChars(l1)
           l2= removeNonReadableChars(l2)
           s << l1 (NLS_("\n"))
           s << l2 (NLS_("\n"))
       }
       s << (NLS_("END\n"))
    }
    close s

}

void readLinkInfoFile(string mn, Skip& skpInfo) {

    Skip   skpLinks
    string absNo, l1, l2
    string fn = getLinkFileName(mn)
    Stream s = read(fn, CP_UTF8)
    if (null s) return

    while (!end(s)) {
        s >> absNo
        if (null absNo) continue
        skpLinks = create
        l1 = (NLS_(""))
        while (l1 != (NLS_("END"))) {
            s >> l1
            if (l1 == (NLS_("END"))) break
            s >> l2
            put(skpLinks, l2, l1)
      }
      put(skpInfo, absNo (NLS_("")), skpLinks)
       
   }

   close s

}


//****************************************************************************
string getVersionSuffix(ModuleVersion modVersion)   // IN : module version
// DESCRIPTION : Returns the version ID of the specified module 
//               in brackets if it is a baseline.
// RETURNS : version string
{
    string sRetval = (NLS_(""))
    if (isBaseline modVersion)
    {
        sRetval = (NLS_("[")) versionString modVersion (NLS_("]")) 
    }
    return sRetval
}


//****************************************************************************
string getNameWithVersion(ModuleVersion modVersion) // IN : Module version
// DESCRIPTION : Returns the full name of the specified module, appending the  
//               version ID in brackets if it is a baseline.
// RETURNS : Name string with version appended.
{
    string sRetVal = fullName modVersion getVersionSuffix(modVersion)
    return  sRetVal
} // getNameWithVersion


//****************************************************************************
string getNameWithVersion(Module m) // IN : module
// DESCRIPTION : Returns the full name of the specified module, appending the  
//               version ID in brackets if it is a baseline.  
// RETURNS : Name string with version appended.
{
    ModuleVersion modVersion = moduleVersion m
    return (getNameWithVersion modVersion)
} // getNameWithVersion

void addLinkToSkip(Skip skpDest, string moduleVersionString, Object o, bool outlink) {

    string absNo
    if (null o) return
    if (!canRead o) return
    absNo = probeAttr_(o, (NLS_("Absolute Number")))
    if (null absNo) return

    if (outlink) 
        link1Buffer = (NLS_("O"))
    else 
        link1Buffer = (NLS_("I"))
    link1Buffer += moduleVersionString
    link2Buffer = absNo (NLS_(":"))
    link2Buffer += linkIdent(o)
    link2Buffer += link1Buffer
    put(skpDest, stringOf(link2Buffer), stringOf(link1Buffer))

}



bool fillLinkListForModule(Module m, bool recurse) {
    Link link
    LinkRef linkref
    Object o
    string s
    Skip skpTemp
    Skip skpObjects
    Skip skpLinks
    string fullmname
    ModuleVersion modVersion
    
    fullmname = getNameWithVersion m

    if (null m) {
        return false
    }

    if (find(nameList, fullmname (NLS_("")))) {
        return true
    }

    modVersion = moduleVersion m
    put(nameList, fullmname (NLS_("")), modVersion) 

    // First, fill a list of all modules linked to this one.
    // Also fill in a list of linked objects, giving any with links an empty skip to store them in

    skpTemp    = create
    skpObjects = create

    for o in m do {
        bool started = false
        string absNo = probeAttr_(o, (NLS_("Absolute Number")))
        if (null absNo) continue

        for linkref in all (o<-(NLS_("*"))) do {
            ModuleVersion modVersion = sourceVersion linkref
            string s = fullName modVersion
            if (!module s) 
            {
                delete modVersion
                continue
            }
            s = s getVersionSuffix(modVersion)
            if (!started) {
                skpLinks = create
                put(skpObjects, absNo, skpLinks)
                started = true
            }

            if (!find(skpTemp, s (NLS_(""))))
            {
                put(skpTemp, s (NLS_("")), modVersion)
            }
            else
            {
                delete modVersion
            }
        }
    
        for link in all (o->(NLS_("*"))) do {
            ModuleVersion modVersion = targetVersion link
            string s = fullName modVersion
            
            if (s == null)
            {
            	delete modVersion
            	continue
            }
            
            if (!module s || isDeleted(module modVersion))
            {
            	delete modVersion
            	continue
            }
			
            s = s getVersionSuffix(modVersion)
            if (!started) {
                skpLinks = create
                put(skpObjects, absNo, skpLinks)
                started = true
            }
            if (!find(skpTemp, s (NLS_(""))))
            {
                put(skpTemp, s (NLS_("")), modVersion)
            }
            else
            {
                delete modVersion
            }
        }
    }

    // Open each of the linked modules in turn to fill in their link information
    for modVersion in skpTemp do {

        
        Module m2 = load(modVersion, false)

        if (null m2) continue

        if (!(isDeleted module modVersion))
        {
            string moduleVersionString = getNameWithVersion(modVersion)
            for o in m do {
                Object other_obj
                string absNo = probeAttr_(o, (NLS_("Absolute Number")))

                if (null absNo) continue
  
                // if this object does not already have an attached list of links, ignore it
                if (!find(skpObjects, absNo, skpLinks)) continue
            
                // fill in details of all links to / from module s
                for link in all (o->(NLS_("*"))) do {
                    ModuleVersion other_mod_ver = targetVersion link

                    if (other_mod_ver != modVersion) 
                    {
                        delete other_mod_ver
                        continue
                    }
                    else 
                    {
                        delete other_mod_ver
                    }

                    other_obj = target link

                    addLinkToSkip(skpLinks, moduleVersionString, other_obj, true) 
                }

                for link in all (o <-(NLS_("*"))) do {
                    ModuleVersion other_mod_ver = sourceVersion link
                    if (other_mod_ver != modVersion) 
                    {
                        delete other_mod_ver
                        continue
                    }
                    else 
                    {
                        delete other_mod_ver
                    }

                    other_obj = source link
                    
                    addLinkToSkip(skpLinks, moduleVersionString, other_obj, false) 
                }
            }
        }
        if ((m != m2) && (!find(skpOpenMods, fullName m2))) close m2
    }

    writeLinkInfoFile(fullmname, skpObjects)    

    for skpLinks in skpObjects do {
        delete skpLinks
    }
    delete skpObjects
    if (!find(skpOpenMods, fullmname)){
        close m
    }
    
    if (recurse) {
        for modVersion in skpTemp do {
            Module nxtModule = load(modVersion, false)
            if (!fillLinkListForModule(nxtModule, recurse)) {
                delete skpTemp
                return false
            }
        }
    }
    delete skpTemp
    return true
}

void dumpSingleMod(Module m) {

    Skip skpTmp
    if ((NLS_("Formal")) != (type m)){ // work on only formal model type
        return
    }

    if (!canRead(m)) return

    isFormal = ((type m) == (NLS_("Formal")))

    if (showLinks) {
        // Read in the cached link information file
        skpLinkInfo = create
        string modNameStr = getNameWithVersion m
        readLinkInfoFile(modNameStr, skpLinkInfo)
    }

    do_htmltable(m)
   
    if (showLinks) {
        for skpTmp in skpLinkInfo do {
            delete skpTmp
        }
        delete skpLinkInfo
    }
}

void copyIfNotExists(string sdir, tdir, sfname, tfname) {
    string s= (NLS_(""))
    if (!fileExists_ tdir tfname) {
        s = copyFile(sdir sfname, tdir tfname)
        if (s != (NLS_(""))) {
            ack dxlStrformat(getExtMsg("String_Icon_copy_failed_n_s",NLSTEMP_("Icon copy failed :\n%s")), s)
        }
    }
}

void copyPictures() {
    copyIfNotExists(imageLocation, exportDir, docTreesName, docTreesName)
    copyIfNotExists(imageLocation, exportDir, bookName, bookName)
    copyIfNotExists(imageLocation, exportDir, worldName, worldName)
    copyIfNotExists(imageLocation, exportDir, docName, docName)
    copyIfNotExists(imageLocation, exportDir, doorsicoName, doorsicoName)
    copyIfNotExists(imageLocation, exportDir, URLouticoName, URLouticoName)
    copyIfNotExists(imageLocation, exportDir, URLinicoName,  URLinicoName)
}

void copyClasses() {
    copyIfNotExists(imageLocation, exportDir, chDateFileSrcName, chDateFileDestName)
}

//****************************************************************************
void findOpenModules()
{
    Module openModule
    for openModule in database do {
        if (canRead openModule) {
            string moduleFullname = getNameWithVersion openModule
            put(skpOpenMods, moduleFullname, moduleFullname)
        }
    }
}

//****************************************************************************
void tidyUpModules() 
{
    Module openModule
    for openModule in database do {
        if (canRead openModule) {
            string moduleFullname = getNameWithVersion openModule             
            if (!find(skpOpenMods, moduleFullname)) {
                close openModule
            }
        }
    }
}

/************************************************************************/
void do_export_file(string db_filename) {
    print "Exporting to HTML"
    int i
    int expSource = 1 //exportAllLinked
    string fName = db_filename
    string expName, modName
    string ps
    bool   cancelled = false
    Module m
    ModuleVersion modVersion
    expMod = current
    QT = (NLS_("\""))

    webDocumentPrefix = (NLS_(""))
    initPictureNames

    topModuleName = fullName expMod
    topModuleFileName = fName

    string fileBase = getenv("USERPROFILE")
    fileBase = fileBase "\\Desktop\\DoorsExport\\"

    exportDir = fileBase
    print "exportDir: " exportDir "\n" 

    if (usePictures) {
        copyPictures
    }

    if (useChangeMeter) {
        copyClasses
    }


    if (null nameList) {
        nameList = create
    } else {
        delete nameList
        nameList = create
    }

    findOpenModules()

    if (expSource == 1) {
        cancelled = !(fillLinkListForModule(expMod, true))
        if (!cancelled) {
            for modVersion in nameList do {
                modName = getNameWithVersion modVersion
                expName = guessExportName(exportDir, modName, extension)
                if (fileOverwriteOK_(expName, overwriteAll)) {
                    expFP = write(expName, CP_UTF8)
                    m = load(modVersion, false)
                    dumpSingleMod(m)
                    close expFP
		                
                    if (!find(skpOpenMods, modName)) {
                        close m
                    }
                    if (quitAfterMemoryWarning)
                    {
                        //user has selected "Halt execution" after memory warning.
                        break;
                    }
                }
            }
        }
    }
    else {
        if (showLinks) 
        {
            cancelled = !(fillLinkListForModule(expMod, false))
        } else 
        {
            // We do not need any of the other modules open
            string fullmn = fullName (module topModuleName)
            put(nameList, fullmn, moduleVersion(expMod))
        }
        if (!cancelled) {
            modName = getNameWithVersion expMod
            expName = guessExportName(exportDir, modName, extension)
            if (fileOverwriteOK_ (expName, overwriteAll)) {
                expFP = write (expName,CP_UTF8)
                dumpSingleMod(expMod)
                close expFP
            }
        }
    }

    tidyUpModules()
    delete nameList
    nameList = null
    delete skpOpenMods
    skpOpenMods = null
    
    // Delete the temporary link information files

    for expName in skpLinkFiles do {
        deleteFile expName
    }

    delete skpLinkFiles   

    setenv((NLS_("ExportDirectory")), getDirOfNoSlash(fName))

    //ready htmlBox

}

print "Starting to export:" dateOf(intOf(today())) "\n" 
Module mod = current
do_export_file(fullName(mod)) 
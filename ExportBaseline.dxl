// Compare baselines
/*
*	Exports the two given baselines' links as text
*/

string fileBase = getenv("USERPROFILE")
fileBase = fileBase "\\Desktop\\BaselineExport"
Stat sta = create fileBase

if (null sta || !directory sta)
{
   mkdir fileBase
}


string outFileName

string outFilePath_left
string outFilePath_right
bool run_once = true

Stream linkStream

// couldn't find the dxl api to load the current state (without baseline) so kept this here
Module currentStateOfModule = current()

pragma runLim, 0

bool parseBaseline(string baselineName, int& major, int& minor)
{
   int offset
   int searchLength
   int strLen = length baselineName

   if (findPlainText(baselineName, ".", offset, searchLength, false))
   {
      major = intOf(baselineName[0:offset - 1])

      minor = intOf(baselineName[offset + 1:strLen])

      return true
   }

   return false
}

void writeLinks(Object o)
{
    Link l
    ModName_ otherMod = null
    ModuleVersion otherVersion = null
    Object othero
    string outLinkedId = null
    
    string linkModName = "*"
    int count = 0
    linkStream << "\tLinks: \n"
    
    for l in all(o->linkModName) do
    {
      count++
    }
    if (count > 0)
    {
       string headings[count]
       int i = 0
       
       for l in all(o->linkModName) do
       {
         otherVersion = targetVersion l
         otherMod = module(otherVersion)
         if (null otherMod || isDeleted otherMod)
         {
             continue
         }

         iTarget= targetAbsNo(l)
         headings[i++] = name(otherMod) "_" iTarget ""
         
       /* TODO: This section will be corrected!!!
           // ensure module is open
           print name(otherMod) "Opening linked module\n"
           if (null data(otherVersion))
           {
              load(otherVersion, false)
           }
           othero = target l

           if (null othero)
           {
               load(otherVersion,false)
               othero = target l
               
               print "Link dest null\n"
           }

           if (null othero) continue
           
           if (isDeleted othero) continue

           outLinkedId = (identifier othero)
           linkStream << "\t\t" outLinkedId "\n"
         */
       }
       //linkStream << "\t\t" count "\n"
    
       sort headings
       for (i = 0; i < count; i++)
       {
       linkStream << "\t\t" headings[i] "\n"
       }
    
    } // links > 0
    
}

void printObjectInfo(Object obj, Skip skipAttrs)
{
   Buffer strBuff = create
   string aName     = ""

   if (isDeleted(obj))
   {
        linkStream << "Deleted Object: " obj."Absolute Number" "\n"
   }
   else
   {
       linkStream << "Object: " obj."Absolute Number" "\n"
       linkStream << "\tHeading/Text: "
       if("" != obj."Object Heading" "")
       {
          linkStream << obj."Object Heading" ""
       }
       else if("" != obj."Object Text" "")
       {
          linkStream << obj."Object Text" ""
       }
       linkStream << "\n"

       linkStream << "\tParent: "

       Object parentObject = parent(obj)
       if(null != parentObject)
       {
          linkStream << parentObject."Absolute Number" ""
       }
       else
       {
          linkStream << "-"
       }

       linkStream << "\n"
       // changes to other attributes
       for aName in skipAttrs do
       {
          linkStream << "\t" aName ": "
          strBuff = probeAttr_(obj, aName)
          linkStream << tempStringOf(strBuff)
          linkStream << "\n"
       }
   }
   delete(strBuff)
}

/******************************************************************************
	Get list of attributes to compare
******************************************************************************/
void getAttrs(Module newMod, Skip attrs)
{
	AttrDef ad = null
	string  adDxl = ""

	// loop through attributes in module
	for ad in newMod do
	{
		if (!null ad)
		{
			// only interested in object attributes
			if (ad.object)
			{
				// exclude system attributes
				if (ad.system && (ad.name != "Last Modified On")) continue

				// exclude DXL attributes
				adDxl = ad.dxl

				if (adDxl "" != "") continue

				// to exclude an attribute insert test for it here
				if (ad.name == "Object Heading") continue
				if (ad.name == "Object Text") continue
				if (ad.name == "ChangeHistory") continue

				put(attrs, ad.name, ad.name)
			}
		}
	}
   
}

void listLinks(Module mod)
{
   Object obj
   Skip skipAttrs = createString

   for obj in entire (mod) do
   {
      getAttrs(mod, skipAttrs)
      printObjectInfo(obj, skipAttrs)
      writeLinks(obj)
      linkStream << "\n"
   }
   delete skipAttrs
}

void writeBaselineToFile(Module mod, string currBaselineStr)
{
      outFileName = fileBase "\\" name(mod) "_Baseline_" currBaselineStr ".txt"
      linkStream = write outFileName
      linkStream << "Module   : " fullName(mod) "\n"
      linkStream << "Baseline : " currBaselineStr "\n"
      listLinks(mod)
      flush linkStream
      close linkStream
}

void findBaselines(Module baseMod, string startBaselineNumber, string endBaselineNumber)
{
   Module foundMod
   Baseline b

   bool startingBaselineEntered
   bool endingBaselineEntered
   bool startingBaselineFound
  // bool endingBaselineFound
   int completed = 0

   int major1 = 0
   int minor1 = 0
   int major2 = 0
   int minor2 = 0
   
   if("" == startBaselineNumber)
   {
      //print "Starting baseline number should be entered.\n"
      return
   }
   else
   {
      if (false == parseBaseline(startBaselineNumber, major1, minor1))
      {
         //print "Baseline not found: " startBaselineNumber "\n"
         return
      }
   }
   
   if("" == endBaselineNumber)
   {
      //print "Ending baseline number is not entered, exporting all baselines.\n"
      major2 = -1
      minor2 = -1
   }
   else
   {
      if(false == parseBaseline(endBaselineNumber, major2, minor2))
      {
         //print "Baseline not found: " endBaselineNumber "\n"
         return
      }

   }

   startingBaselineFound = false
   // endingBaselineFound = false
   for b in baseMod do
   {
      string currBaselineStr = major (b) "" "." minor (b) ""
      
      if ((major (b) == major1)&&(minor(b) == minor1))
      {
         //print "Found starting baseline:" currBaselineStr "\n"
         startingBaselineFound = true
      }
      if ((major (b) == major2)&&(minor(b) == minor2))
      {
         //print "Found ending baseline!\n"
         //endingBaselineFound = true
      }

      if(true == startingBaselineFound)
      {
         outFileName = fileBase "\\" name(baseMod) "_Baseline_" currBaselineStr ".txt"
         //print "Writing file: " outFileName "\n"
         
         linkStream = write outFileName
         foundMod = load (baseMod, b, false)
         linkStream << "Module   : " fullName(foundMod) "\n"
         linkStream << "Baseline : " currBaselineStr "\n"
         linkStream << "Suffix   : " suffix(b) "\n"
         linkStream << "Description : " annotation(b) "\n"
         listLinks(foundMod)
         flush linkStream
         close linkStream
         if (true == run_once)
         {
            run_once = false
            outFilePath_left = outFileName
         }
      }

      if (((major (b) == major2)&&(minor(b) == minor2)))
      {
         //print "Finished!\n"
         break
      }
   }
   
   if ((-1 == major2)&&(-1 == minor2))
   {
      //print "Found ending baseline!"

      writeBaselineToFile(currentStateOfModule, "current")
      
      //print "Writing file: " outFileName "\n"
      
   }
   outFilePath_right = outFileName
   //print "Completed!\n"
}

DB baselineBox = create "Baselines"
DBE baseLineStart = field(baselineBox, "Starting Baseline Number:", "", 10) 
DBE baseLineEnd = field(baselineBox, "Ending Baseline Number:", "", 10) 

string baseline1Str

void getString(DB exBox)
{
   string startingBaselineNumber = get baseLineStart
   string endingBaselineNumber = get baseLineEnd

   destroy exBox

   findBaselines(current Module, startingBaselineNumber, endingBaselineNumber)
   //print "Runnig Beyond Compare\n"
   system "C:\\Program Files\\Beyond Compare 4\\BCompare.exe " outFilePath_left " " outFilePath_right
}

apply(baselineBox, getString) 
show baselineBox